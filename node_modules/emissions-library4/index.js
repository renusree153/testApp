import * as Location from 'expo-location'
import { Text, StyleSheet, View, Button, Switch, Alert,  AsyncStorage} from 'react-native';
import React, {useState, useEffect, useRef, Component, useContext} from 'react';
import database1 from 'emissions-library4/firebase';
import firebase from 'firebase/compat/app';
import firestore from "firebase/compat/firestore";
import { getDatabase, ref, onValue, set } from "firebase/compat/firestore";
import { collection, addDoc } from "firebase/compat/firestore"; 
import { doc, setDoc } from "firebase/firestore"; 
import dataPlan, { DataPlanProvider } from '../../src/context';
// if I have asyncStorage do I need context anymore?

let dataPlanArray = [];

export default function LocationFinder () {
  return (
    <DataPlanProvider>
      <LocationFinderComponent />
    </DataPlanProvider>
  )
}

function LocationFinderComponent () {
  const [location, setLocation] = useState(null);
  const [errorMsg, setErrorMsg] = useState(null);
  const [localStorageData, setLocalStorageData] = useState(null);
  const [isRunning, setIsRunning] = useState(true);
  const intervalIdRef = useRef(null);
  // useRef will  persist btw renders, doesnt cause component to reupdate on change
  // how can I get state of isEnabled into the useEffect
  useEffect(() => {
    if (!isRunning) {
      return;
    }
    (async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      let dataPlanString = await AsyncStorage.getItem('isEnabled');
      let dataPlan = JSON.parse(dataPlanString);
      // gets dataPlan value from AsyncStorage which persists betweeen screen shifts
      console.log("this is the data plan type " + typeof(dataPlan) + dataPlan)
      console.log("data plan array length " + dataPlanArray.length);
      if (status !== 'granted') {
        setErrorMsg('Permission to access location was denied');
        return;
      }
      async function updateLocation () {
        let acquired_location = await Location.getCurrentPositionAsync({});
        setLocation(acquired_location);
        console.log("data Plan value " + dataPlan);
        if (!dataPlan) {
          console.log("data plan is set to false so currently pushing to temporary array");
          // this is still printing after I set the value fo true which is weird
          dataPlanArray.push(acquired_location);
        }
        else if (dataPlan&& (dataPlanArray.length != 0)) {
          for (let i = 0; i < dataPlanArray.length; i++) {
            create(dataPlanArray[i]);
            console.log(dataPlanArray[i]);
          }
          dataPlanArray = [];
        }
        else {
          create(acquired_location);
          console.log(acquired_location);
        }
      }
      intervalIdRef.current = setInterval(updateLocation, 5000);
      return () => clearInterval(intervalIdRef.current);
    })();
  }, [isRunning, dataPlan]);

  const create = (acquired_location) => {
    const db = firebase.firestore();
    db.collection('LocationCollector').add({
      locationVal: acquired_location,
      collectedTime: firebase.firestore.FieldValue.serverTimestamp() // gives date, hour, min, second
    });
  }

  function endTrip () {
    console.log("in endTrip button");
    clearInterval(intervalIdRef.current);
    // best practice to clear the interval even though we are changing the isRunning state to false
    setIsRunning(false);
  }

  function restartTrip () {
    console.log("in restart trip button");
    setIsRunning(true);
  }

  function surveyAlert () {
    Alert.alert (
      'Would you like to take a survey?', 
      '',
      [
        {
          text: 'Yes', onPress: () => {
            console.log("yes pressed");
          }
          // will want this to forward to a survey later
        },
        {
          text: 'No', onPress: () => {
            console.log("no pressed");
          }
        }
      ],
      {cancelable: false},
      // makes sure user can't press out of the alert and close out 
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.paragraph}>Your location data is currently being stored in firestore</Text>
      <Button 
      title = "End my Trip"
      onPress = {() => { endTrip(); surveyAlert();}}
      />
      <Button 
      title = "Restart my Trip"
      onPress = { () => restartTrip()}
      />
    </View>
  );
}
// understand how useContext works here and why we needed to wrap it in another function
export function Details () {
  return (
    <DataPlanProvider>
      <DetailsContent />
    </DataPlanProvider>
  )
}

function DetailsContent () {
  const {isEnabled, setIsEnabled} = useContext(dataPlan);
  useEffect(() => {
    (async () => {
      try {    
        const value = await AsyncStorage.getItem('isEnabled');
        if (value !== null) {
          setIsEnabled(JSON.parse(value));
        }
        // when the user closes out of component & reopens it resets the isEnabled
        // to correct value received from asynStorage
      } catch (error) {
        console.error(error);
      }
    })();
  }, []);
  console.log(isEnabled);
  const toggleSwitch = async () => {
    const newValue = !isEnabled;
    setIsEnabled(newValue);
    try {
      await AsyncStorage.setItem('isEnabled', JSON.stringify(newValue));
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View styles={styles.container}>
      <Text style={styles.paragraph}>Would you like to use your data plan?</Text>
      <Switch
        trackColor={{ false: '#767577', true: '#81b0ff' }}
        thumbColor={isEnabled ? '#f5dd4b' : '#f4f3f4'}
        onValueChange={toggleSwitch}
        value={isEnabled}
      />
    </View>
  );
}

export function SignIn () {
  return (
    <View styles = {styles.containter} > 
      <Text style = {styles.paragraph} > This is the sign in method to be further developed </Text>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  paragraph: {
  fontSize: 18,
  textAlign: 'center',
  },
});
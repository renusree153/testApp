{"version":3,"file":"443c35ce.js","sources":["../src/utils/error.ts","../src/utils/hash.ts","../src/utils/stringifyVariables.ts","../src/utils/request.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr) return `[Network] ${networkErr.message}`;\n  if (graphQlErrs) {\n    for (const err of graphQlErrs) {\n      if (error) error += '\\n';\n      error += `[GraphQL] ${err.message}`;\n    }\n  }\n  return error;\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor(input: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (input.graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(\n      input.networkError,\n      normalizedGraphQLErrors\n    );\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = input.networkError;\n    this.response = input.response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","export type HashValue = number & { readonly _opaque: unique symbol };\n\n// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (x: string, seed?: HashValue): HashValue => {\n  let h = typeof seed === 'number' ? seed | 0 : 5381;\n  for (let i = 0, l = x.length | 0; i < l; i++)\n    h = (h << 5) + h + x.charCodeAt(i);\n  return h as HashValue;\n};\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let value of x) {\n      if (out !== '[') out += ',';\n      value = stringify(value);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (const key of keys) {\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import {\n  Location,\n  DefinitionNode,\n  DocumentNode,\n  Kind,\n  parse,\n  print,\n} from 'graphql';\n\nimport { HashValue, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { TypedDocumentNode, AnyVariables, GraphQLRequest } from '../types';\n\ninterface WritableLocation {\n  loc: Location | undefined;\n}\n\nexport interface KeyedDocumentNode extends DocumentNode {\n  __key: HashValue;\n}\n\nconst SOURCE_NAME = 'gql';\nconst GRAPHQL_STRING_RE = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nconst REPLACE_CHAR_RE = /(#[^\\n\\r]+)?(?:\\n|\\r\\n?|$)+/g;\n\nconst replaceOutsideStrings = (str: string, idx: number) =>\n  idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\\n') : str;\n\nconst sanitizeDocument = (node: string): string =>\n  node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();\n\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  const printed = sanitizeDocument(\n    typeof node === 'string'\n      ? node\n      : node.loc && node.loc.source.name === SOURCE_NAME\n      ? node.loc.source.body\n      : print(node)\n  );\n\n  if (typeof node !== 'string' && !node.loc) {\n    (node as WritableLocation).loc = {\n      start: 0,\n      end: printed.length,\n      source: {\n        body: printed,\n        name: SOURCE_NAME,\n        locationOffset: { line: 1, column: 1 },\n      },\n    } as Location;\n  }\n\n  return printed;\n};\n\nconst hashDocument = (\n  node: string | DefinitionNode | DocumentNode\n): HashValue => {\n  let key = phash(stringifyDocument(node));\n  // Add the operation name to the produced hash\n  if (typeof node === 'object' && 'definitions' in node) {\n    const operationName = getOperationName(node);\n    if (operationName) key = phash(`\\n# ${operationName}`, key);\n  }\n  return key;\n};\n\nconst docs = new Map<HashValue, KeyedDocumentNode>();\n\nexport const keyDocument = (node: string | DocumentNode): KeyedDocumentNode => {\n  let key: HashValue;\n  let query: DocumentNode;\n  if (typeof node === 'string') {\n    key = hashDocument(node);\n    query = docs.get(key) || parse(node, { noLocation: true });\n  } else {\n    key = (node as KeyedDocumentNode).__key || hashDocument(node);\n    query = docs.get(key) || node;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\nexport const createRequest = <\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  q: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> => {\n  if (!variables) variables = {} as Variables;\n  const query = keyDocument(q);\n  const printedVars = stringifyVariables(variables);\n  let key = query.__key;\n  if (printedVars !== '{}') key = phash(printedVars, key);\n  return { key, query, variables };\n};\n\n/**\n * Finds the Name value from the OperationDefinition of a Document\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\n/**\n * Finds the operation-type\n */\nexport const getOperationType = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n","import { ExecutionResult, Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: ExecutionResult,\n  response?: any\n): OperationResult => {\n  if ((!('data' in result) && !('errors' in result)) || 'path' in result) {\n    throw new Error('No Content');\n  }\n\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors)\n      ? new CombinedError({\n          graphQLErrors: result.errors,\n          response,\n        })\n      : undefined,\n    extensions:\n      (typeof result.extensions === 'object' && result.extensions) || undefined,\n    hasNext: !!result.hasNext,\n  };\n};\n\nexport const mergeResultPatch = (\n  prevResult: OperationResult,\n  patch: ExecutionResult,\n  response?: any\n): OperationResult => {\n  const result = { ...prevResult };\n  result.hasNext = !!patch.hasNext;\n\n  if (!('path' in patch)) {\n    if ('data' in patch) result.data = patch.data;\n    return result;\n  }\n\n  if (Array.isArray(patch.errors)) {\n    result.error = new CombinedError({\n      graphQLErrors: result.error\n        ? [...result.error.graphQLErrors, ...patch.errors]\n        : patch.errors,\n      response,\n    });\n  }\n\n  let part: Record<string, any> | Array<any> = (result.data = {\n    ...result.data,\n  });\n\n  let i = 0;\n  let prop: string | number;\n  while (i < patch.path.length) {\n    prop = patch.path[i++];\n    part = part[prop] = Array.isArray(part[prop])\n      ? [...part[prop]]\n      : { ...part[prop] };\n  }\n\n  Object.assign(part, patch.data);\n  return result;\n};\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import {\n  stringifyDocument,\n  getOperationName,\n  stringifyVariables,\n} from '../utils';\nimport { AnyVariables, GraphQLRequest, Operation } from '../types';\n\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nexport function makeFetchBody<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(request: Omit<GraphQLRequest<Data, Variables>, 'key'>): FetchBody {\n  return {\n    query: stringifyDocument(request.query),\n    operationName: getOperationName(request.query),\n    variables: request.variables || undefined,\n    extensions: undefined,\n  };\n}\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod =\n    operation.kind === 'query' && operation.context.preferGetMethod;\n  if (!useGETMethod || !body) return operation.context.url;\n\n  const url = new URL(operation.context.url);\n  const search = url.searchParams;\n  if (body.operationName) search.set('operationName', body.operationName);\n  if (body.query) search.set('query', body.query);\n  if (body.variables)\n    search.set('variables', stringifyVariables(body.variables));\n  if (body.extensions)\n    search.set('extensions', stringifyVariables(body.extensions));\n\n  const finalUrl = url.toString();\n  if (finalUrl.length > 2047 && useGETMethod !== 'force') {\n    operation.context.preferGetMethod = false;\n    return operation.context.url;\n  }\n\n  return finalUrl;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod =\n    operation.kind === 'query' && !!operation.context.preferGetMethod;\n  const headers: HeadersInit = {\n    accept: 'application/graphql+json, application/json',\n  };\n  if (!useGETMethod) headers['content-type'] = 'application/json';\n  const extraOptions =\n    (typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions) || {};\n  if (extraOptions.headers)\n    for (const key in extraOptions.headers)\n      headers[key.toLowerCase()] = extraOptions.headers[key];\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers,\n  };\n};\n","import { Source, make } from 'wonka';\nimport { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult, mergeResultPatch } from '../utils';\n\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nconst jsonHeaderRe = /content-type:[^\\r\\n]*application\\/json/i;\nconst boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\n\ntype ChunkData = { done: false; value: Buffer | Uint8Array } | { done: true };\n\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nconst toString = (input: Buffer | ArrayBuffer): string =>\n  input.constructor.name === 'Buffer'\n    ? (input as Buffer).toString()\n    : decoder!.decode(input as ArrayBuffer);\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Source<OperationResult> => {\n  const maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;\n  const fetcher = operation.context.fetch;\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n    if (abortController) {\n      fetchOptions.signal = abortController.signal;\n    }\n\n    let hasResults = false;\n    // DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>\n    // See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts\n    const executeIncrementalFetch = (\n      onResult: (result: OperationResult) => void,\n      operation: Operation,\n      response: Response\n    ): Promise<void> => {\n      // NOTE: Guarding against fetch polyfills here\n      const contentType =\n        (response.headers && response.headers.get('Content-Type')) || '';\n      if (/text\\//i.test(contentType)) {\n        return response.text().then(text => {\n          onResult(makeErrorResult(operation, new Error(text), response));\n        });\n      } else if (!/multipart\\/mixed/i.test(contentType)) {\n        return response.text().then(payload => {\n          onResult(makeResult(operation, JSON.parse(payload), response));\n        });\n      }\n\n      let boundary = '---';\n      const boundaryHeader = contentType.match(boundaryHeaderRe);\n      if (boundaryHeader) boundary = '--' + boundaryHeader[1];\n\n      let read: () => Promise<ChunkData>;\n      let cancel = () => {\n        /*noop*/\n      };\n      if (response[Symbol.asyncIterator]) {\n        const iterator = response[Symbol.asyncIterator]();\n        read = iterator.next.bind(iterator);\n      } else if ('body' in response && response.body) {\n        const reader = response.body.getReader();\n        cancel = () => reader.cancel();\n        read = () => reader.read();\n      } else {\n        throw new TypeError('Streaming requests unsupported');\n      }\n\n      let buffer = '';\n      let isPreamble = true;\n      let nextResult: OperationResult | null = null;\n      let prevResult: OperationResult | null = null;\n\n      function next(data: ChunkData): Promise<void> | void {\n        if (!data.done) {\n          const chunk = toString(data.value);\n          let boundaryIndex = chunk.indexOf(boundary);\n          if (boundaryIndex > -1) {\n            boundaryIndex += buffer.length;\n          } else {\n            boundaryIndex = buffer.indexOf(boundary);\n          }\n\n          buffer += chunk;\n          while (boundaryIndex > -1) {\n            const current = buffer.slice(0, boundaryIndex);\n            const next = buffer.slice(boundaryIndex + boundary.length);\n\n            if (isPreamble) {\n              isPreamble = false;\n            } else {\n              const headersEnd = current.indexOf('\\r\\n\\r\\n') + 4;\n              const headers = current.slice(0, headersEnd);\n              const body = current.slice(\n                headersEnd,\n                current.lastIndexOf('\\r\\n')\n              );\n\n              let payload: any;\n              if (jsonHeaderRe.test(headers)) {\n                try {\n                  payload = JSON.parse(body);\n                  nextResult = prevResult = prevResult\n                    ? mergeResultPatch(prevResult, payload, response)\n                    : makeResult(operation, payload, response);\n                } catch (_error) {}\n              }\n\n              if (next.slice(0, 2) === '--' || (payload && !payload.hasNext)) {\n                if (!prevResult)\n                  return onResult(makeResult(operation, {}, response));\n                break;\n              }\n            }\n\n            buffer = next;\n            boundaryIndex = buffer.indexOf(boundary);\n          }\n        } else {\n          hasResults = true;\n        }\n\n        if (nextResult) {\n          onResult(nextResult);\n          nextResult = null;\n        }\n\n        if (!data.done && (!prevResult || prevResult.hasNext)) {\n          return read().then(next);\n        }\n      }\n\n      return read().then(next).finally(cancel);\n    };\n\n    let ended = false;\n    let statusNotOk = false;\n    let response: Response;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) return;\n        return (fetcher || fetch)(url, fetchOptions);\n      })\n      .then((_response: Response | void) => {\n        if (!_response) return;\n        response = _response;\n        statusNotOk = response.status < 200 || response.status >= maxStatus;\n        return executeIncrementalFetch(next, operation, response);\n      })\n      .then(complete)\n      .catch((error: Error) => {\n        if (hasResults) {\n          throw error;\n        }\n\n        const result = makeErrorResult(\n          operation,\n          statusNotOk\n            ? response.statusText\n              ? new Error(response.statusText)\n              : error\n            : error,\n          response\n        );\n\n        next(result);\n        complete();\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["generateErrorMessage","networkErr","graphQlErrs","message","err","error","rehydrateGraphQlError","GraphQLError","nodes","source","positions","path","extensions","CombinedError","Error","constructor","input","normalizedGraphQLErrors","graphQLErrors","map","name","networkError","response","phash","x","seed","h","i","l","length","charCodeAt","seen","Set","cache","WeakMap","stringify","toJSON","Array","isArray","value","out","keys","Object","set","key","add","delete","stringifyVariables","SOURCE_NAME","GRAPHQL_STRING_RE","REPLACE_CHAR_RE","replaceOutsideStrings","str","idx","replace","sanitizeDocument","node","split","join","trim","stringifyDocument","printed","loc","body","print","start","hashDocument","operationName","getOperationName","docs","Map","keyDocument","query","get","parse","noLocation","__key","createRequest","q","variables","printedVars","definitions","getOperationType","kind","Kind","OPERATION_DEFINITION","makeResult","operation","result","undefined","hasNext","mergeResultPatch","prevResult","patch","data","errors","part","prop","makeErrorResult","makeFetchBody","request","makeFetchURL","useGETMethod","context","preferGetMethod","url","search","searchParams","finalUrl","toString","makeFetchOptions","headers","accept","fetchOptions","extraOptions","toLowerCase","JSON","decoder","TextDecoder","jsonHeaderRe","boundaryHeaderRe","decode","makeFetchSource","maxStatus","redirect","fetcher","fetch","abortController","AbortController","signal","contentType","test","onResult","text","payload","boundaryHeader","boundary","read","Symbol","asyncIterator","TypeError","done","boundaryIndex","buffer","indexOf","next","slice","isPreamble","current","headersEnd","lastIndexOf","nextResult","then","finally","cancel","ended","_response","statusNotOk","status","catch","hasResults","statusText","complete"],"mappings":"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"}